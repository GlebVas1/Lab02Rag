                   Модели данных
Модель данных описывает некоторый набор родовых понятий и признаков,
которыми должны обладать все конкретные СУБД и управляемые ими базы
данных, основанные на этой модели.
По К. Дейту для любой модели данных принято выделять три части:
1. Структурная часть – описывает основные логические структуры данных,
    которые могут применяться на уровне пользователя при организации БД
2. Манипуляционная часть – обеспечивает модельный язык БД
3. Целостная часть – специфицирует механизмы ограничений целостности,
    которые обязательно должны поддерживаться во всех реализациях СУБД
Изученные модели данных:
• Дореляционные (60-е – 70-е г.г.):
    • Иерархическая – деревья
    • Сетевая – произвольные ориентированные графы
    • Инвентированные списки – таблицы с физической адресацией
        записей
• Реляционная (Э. Кодд, 1969 г.)
• Модель данных SQL
  Проблема «потери соответствия»
К началу 90-х годов SQL-ориентированные СУБД заняли на мировом рынке
доминирующее положение, которое удерживают и по настоящий момент.

В 80-е годы стала приобретать популярность парадигма объектно-
ориентированного программирования (языки Smalltalk, Ada, Objective-C, C++).
В 90-e годы объектно-ориентированное программирование вошло в моду и
стало завоевывать преимущественное положение в программной индустрии.
Большая часть современных производственных приложений, связанных с
потребностью в обработке больших объемов данных, разрабатывается на
различных объектно-ориентированных языках (C++, Java, C#).

В связи с этим возникла проблема «потери соответствия» (impedance
mismatch) между системами типов и средствами доступа к данным объектно-
ориентированных языков программирования и SQL-ориентированных СУБД.
Это затрудняет разработку приложений, которые по своей специфике
вынуждены часто обращаться к базе данных для доступа к требуемым им
данным.
                     Первый манифест
1989 г., М. Аткинсон и др., «Манифест систем объектно-ориентированных баз данных»:
    • Необходимо преодолеть несоответствие между типами данных, используемыми в
    языках программирования, и типами данных, поддерживаемыми в СУБД;
    • СУБД должна иметь возможность хранить данные произвольно сложной
    структуры и обеспечивать развитую систему типов данных;
    • Реляционная модель данных и язык SQL являются ограниченными и не подходят
    для этих целей;
    • Предлагается использовать в СУБД объектно-ориентированную модель и
    формулируются базовые требования к ООСУБД.

К этому времени уже существовало несколько реализаций ООСУБД, но каждая из них
опиралась на некоторое расширение объектной модели какого-либо объектно-
ориентированного языка программирования (Smalltalk, Object Lisp, C++), отсутствовали
какие-либо общие подходы.
Под влиянием Первого манифеста в 1991 г. возник консорциум ODMG (Object Database
Management Group), задачей которого была разработка стандарта объектно-
ориентированной модели данных. За 10 лет своего существования этот консорциум
подготовил три версии стандарта (опубликованы как книги издательства Morgan
Kaufmann), основные положения стандарта ODMG 3.0 мы рассмотрим в ходе данной
лекции.
                   Второй манифест
1990 г., М. Стоунбрейкер и др., «Манифест систем баз данных третьего
поколения»:
    • СУБД должна иметь возможность хранить данные произвольно сложной
    структуры и обеспечивать развитую систему типов данных;
    • Можно добиться требуемых результатов, эволюционно развивая SQL;
    • Идея использовать новую модель данных – слишком революционна.

Второй манифест во многом направлен на защиту инвестиций крупных
компаний-производителей программного обеспечения SQL-ориентированных
СУБД. За публикацией второго манифеста последовало появление объектно-
реляционных продуктов ведущих компаний-поставщиков SQL-
ориентированных СУБД (Informix Universal Server, Oracle8, IBM DB2 Universal
Database).
В 1999 г. был принят стандарт языка SQL (SQL:1999), в котором был
зафиксирован ряд новых черт языка, придающих ему черты полноценной
модели данных с развитой системой типов данных, эта модель была уточнена и
расширена в стандарте SQL:2003. В этой лекции рассмотрим объектные
расширения SQL.
                     Третий манифест
1995 г., К. Дейт, Х. Дарвен, «Третий манифест»:
    • Идеи первых двух манифестов необоснованы, плохо проработаны, избыточны и
    даже вредны за исключением общей идеи о потребности обеспечения развитой
    системы типов данных:
            В первом манифесте реляционная модель данных отвергается полностью;
            Во втором она заменяется еще незрелой к тому времени моделью данных
              SQL, которая уже тогда была далека от реляционной модели;
    • Классическая реляционная модель данных (в ее первозданном виде согласно
    ранних статей Э. Кодда) необходима и достаточна для использования в
    современных СУБД.

Третий манифест являлся одновременно наиболее консервативным и наиболее
радикальным. Консервативность заключается в том, что его авторы всеми силами
утверждают необходимость и достаточность использования в системах базах данных
следующего поколения классической реляционной модели данных. Радикальность
состоит в том, что авторы полностью отрицают подходы, предлагаемые в первых двух
манифестах и предлагают вернуться к истокам реляционной модели данных, фактически
отбросив технологию, созданную индустрией баз данных за 25 лет.
                     Третий манифест
В дальнейшем Дейт и Дарвен выпустили три книги, в которых достаточно
подробно изложили свой подход к построению СУБД на основе (как они
утверждают) «истинных идей Эдгара Кодда, изложенных им в своих первых
статьях про реляционную модель данных»:
    • «Foundation for Object/Relational Databases: The Third Manifesto» (1998);
    • «Foundation for Future Database Systems: The Third Manifesto» (2000);
    • «Databases, Types and the Relational Model: The Third Manifesto» (2006).
Однако некоторые более поздние идеи Кодда относительно той же
реляционной модели авторами отвергаются.

На самом деле, Дейт и Дарвен предложили некоторый современный вариант
реляционной модели данных, который можно назвать «истинной
реляционной» моделью. В ходе лекции будут рассмотрены основные свойства
этой модели.
   Объектно-ориентированная модель
В объектно-ориентированной модели данных база данных – это
набор объектов (контейнеров данных) произвольного типа.
В этом заключается ее принципиальное отличие от SQL-
ориентированной и реляционной моделей данных, где база
данных представляет собой набор именованных контейнеров
данных одного родового типа: таблиц или отношений
соответственно.

В объектно-ориентированной модели данных вводятся две
разновидности типов: литеральные и объектные типы.
Экземпляры литеральных типов не имеют собственного
идентификатора и не могут самостоятельно храниться в базе
данных.
Экземпляры объектных типов идентифицируются и хранятся.
         Литеральные типы данных
Литеральные типы данных – могут использоваться в качестве типов атрибутов
внутри объектов. Значения литеральных типов не могут самостоятельно
храниться в базе данных.
Атомарные литеральные типы: числовые, символьные, булевские,
темпоральные (принятые как в традиционных языках программирования, так и
в языках баз данных).
Конструируемые литеральные типы:
    • Запись (аналог структуры в языках C/C++, может включать атрибуты
       объектных типов)
    • Коллекции (типом элемента может являться любой скалярный или
       объектный тип, кроме того же типа коллекции):
         Множество (неупорядоченная, без дубликатов)
         Мультимножество (неупорядоченная, с дубликатами)
         Массив (упорядоченная, с возможностью доступа к элементу по
           индексу)
         Список (упорядоченная, с возможностью быстрой вставки и
           удаления элементов)
         Словарь (множество пар <ключ, значение>)
            Объектные типы данных
Объектные типы данных: атомарные (классы) и объектные коллекции.
Значения объектных типов имеют объектный идентификатор (OID) и могут
самостоятельно храниться в базе данных.
OID автоматически генерируется СУБД, является уникальным во всей БД, не
зависит от состояния объекта (значений его атрибутов).
Каждый объектный тип имеет операцию создания и инициализации
(конструктор). В качестве результата она возвращает OID созданного объекта.
OID может храниться везде, где допускается хранение объектов данного типа, и
использоваться для обращения к операциям объекта, определенным для его
объектного типа.
При определении атомарного объектного типа указывается его внутренняя
структура (набор свойств: атрибутов и связей) и набор операций, которые
можно применять к объектам этого типа.
Для определения атомарного объектного типа можно использовать механизм
наследования, расширяя набор свойств и/или переопределяя существующие и
добавляя новые операции. Одиночное наследование поддерживается в
обязательном порядке, поддержка множественного наследования является
желательной.
                    Свойства объекта
Атрибутами называются свойства объекта, значение которых можно получить
по OID объекта. Значениями атрибутов могут быть и литералы, и объекты (т.е.
OID), но только тогда, когда не требуется инверсная (обратная) ссылка.

Связи – это инверсные свойства и их значением может быть только объект или
коллекция объектов. В объектной модели ODMG поддерживаются только
бинарные связи, т.е. связи между двумя атомарными объектными типами.
Связи могут быть разновидностей «один-к-одному», «один-ко-многим» и
«многие-ко-многим» в зависимости от того, сколько экземпляров
соответствующего объектного типа может участвовать в связи. Единственным
способом реализации связей является хранение в объекте OID или коллекции
OID связанных объектов в зависимости от вида связи. Явное определение связи
обеспечивает системе дополнительную информацию, которая используется в
объектной модели как ограничение целостности.
                Объектные коллекции
Можно определить пять объектных типов коллекций: множество, мультимножество,
массив, список и словарь. Типом элемента объектного типа коллекции может быть
любой литеральный или объектный тип, кроме того же типа коллекции.
В отличие от литеральных коллекций, объектные коллекции могут самостоятельно
храниться в БД (объектные коллекции имеют свой собственный OID).
В отличие от атомарных объектных типов набор операций для каждого из типов
коллекций предопределен.

При определении атомарного объектного типа можно в качестве одного из
дополнительных свойств этого типа указать, что для него должен быть создан объект
типа множества, элементами которого являются объекты данного атомарного типа. Это
множество называется экстентом объектного типа.
Поскольку экстент создается неявно, его OID неизвестен, но зато у него имеется имя,
явно задающееся в определении и совпадающее с именем атомарного объектного типа.
Наличие этой возможности позволяет создавать объектные базы данных, состоящие из
именованных контейнеров однотипных объектов (экстентов), содержащих в
действительности OID этих объектов.
Поддерживается семантика включения: экстент подтипа является подмножеством
экстента любого своего супертипа.
    Виды эквивалентности объектов
В связи с наличием у объектов уникальных идентификаторов различают три
вида эквивалентности объектов:
1. Эквивалентность по идентификации (идентичность): объекты являются
    идентичными тогда и только тогда, когда их идентификаторы совпадают.
2. Поверхностная эквивалентность: два объекта поверхностно эквивалентны
    тогда и только тогда, когда их свойства идентичны (выполняется
    поверхностное сравнение: простые атрибуты сравниваются по значению, а
    объектные и связи – по идентификатору).
3. Эквивалентность по значению (равенство): два объекта равны тогда и
    только тогда, когда значения всех их свойств одинаковы (выполняется
    глубокое сравнение: при наличии атрибутов объектного типа и связей
    рекурсивно проверяется равенство соответствующих объектов).

Очевидно, что два идентичных объекта будут также равны и поверхностно
эквивалентны, в то время как обратное неверно. Аналогично, поверхностная
эквивалентность объектов означает их равенство, но не наоборот.
                           Язык OQL
OQL (Object Query Language) – базовое средство манипулирования в объектно-
ориентированной модели.
• OQL не является вычислительно полным языком. Он представляет собой
простой язык запросов (обеспечивается декларативный доступ к объектам).
• OQL очень близок по синтаксису к SQL/92. Расширения относятся к объектно-
ориентированным понятиям, таким как объекты, объектные идентификаторы,
путевые выражения, полиморфизм, вызов операций и т.п.
• В OQL поддерживаются средства доступа ко всем возможным структурам
данных (записям, коллекциям), допускаемых в модели ODMG.
• OQL является функциональным языком, допускающим неограниченную
композицию операций, если операнды не выходят на пределы системы типов
(результат любого запроса обладает типом, принадлежащим к модели ODMG, и
поэтому к результату запроса может быть применен новый запрос).
• Операторы языка OQL могут вызываться из любого языка программирования,
для которого определены правила связывания. И, наоборот, в запросах OQL
могут присутствовать вызовы операций, запрограммированных на этих языках.
• В OQL не определяются явные операции обновления, а используются вызовы
операций, определенных в объектах для целей обновления.
                            Язык OQL
Результатом допустимых в OQL выражений запросов могут являться:
    • индивидуальный объект;
    • коллекция объектов;
    • коллекция литеральных значений;
    • индивидуальное литеральное значение.

Пример: определить руководителей отделов и тех служащих их отделов,
зарплата которых превышает 20000 руб.
SELECT DISTINCT STRUCT ( DEPT_MNG: D.DEPT_MANAGER,
                        EMP: ( SELECT E FROM D.CONSISTS_OF AS E WHERE
E.EMP_SALARY > 20000.00 )
        ) FROM DEPARTMENTS D;
DEPARTMENTS – имя экстента объектного типа DEPARTMENT
CONSISTS_OF – имя роли (конца связи) типа EMPLOYEE в связи с типом
DEPARTMENT
Результат запроса имеет тип set <struct { OID <EMPLOYEE> DEPT_MNG; bag <
EMPLOYEE> EMP }>
         Прочие языковые средства
Язык ODL (Object Definition Language) – позволяет описывать схему БД в виде
набора интерфейсов объектных типов (описание атрибутов, связей между
объектными типами, а также операций и их параметров). ODL не является
языком программирования, требуются средства отображения конструкций ODL
в объектно-ориентированные языки программирования для реализации типов.

В качестве языка манипулирования объектами (создание, модификация,
удаление) предполагается использование объектно-ориентированных языков
программирования. С этой целью языки программирования расширяются
дополнительными конструкциями либо для них реализуется библиотека,
поддерживающая соответствующую функциональность. Правила связывания в
курсе лекций не рассматриваются. Рассмотрим лишь основные подходы к
созданию и удалению объектов.
       Подходы к созданию и удалению
                  объектов
Различают перманентные (persistent) и транзитные (transient) объекты. Первые реально
сохраняются в БД, т.е. приобретают свойство хранимости (устойчивости). Вторые
существуют временно в течение сеанса работы приложения.
Существуют следующие подходы к созданию (конструированию) объектов:
1. Создание экземпляра (путем вызова его конструктора) приводит к его добавлению в
   базу данных (автоматически предполагается устойчивость экземпляров).
2. Вызов конструктора предполагает создание транзитного экземпляра. Тогда
   созданный во время работы программы объект уничтожается при ее завершении,
   если он не сделан устойчивым путем вызова специального метода.
3. Возможно конструировать как перманентные, так и транзитные экземпляры. Тип
   создаваемого экземпляра определяется специальным параметром конструктора.
Удаление объектов может осуществляться двумя альтернативными способами:
1. Объект физически удаляется в любом случае. Контроль ссылочной целостности на
   уровне СУБД при этом не производится и полностью возлагается на приложение.
2. Объект имеет счетчик ссылок на него, при ненулевом значении этого счетчика
   вместо уничтожения объекта выставляется "флаг уничтожения" (tombstone), и объект
   удаляется только после того, как счетчик обнулится.
    Поддержка целостности данных
В модели ODMG два объекта считаются совпадающими (идентичными) в том и
только в том случае, когда являются одним и тем же объектом, т.е. имеют один
и тот же OID. Объекты одного объектного типа с разными OID считаются
разными (не идентичными), даже если обладают полностью совпадающими
состояниями. Поэтому в объектной модели отсутствует аналог проверочного
ограничения целостности сущности реляционной модели данных.

Ссылочная целостность поддерживается для связей «один-ко-многим». В этом
случае объекты на стороне связи «один» рассматриваются как предки, а
объекты на стороне связи «многие» – как потомки, и ООСУБД обязана следить
за тем, чтобы не образовывались потомки без предков.
     Объектно-ориентированные СУБД
Проведенный в 2007 г. обзор: db4o, Objectivity/DB, Versant
• Ни одна из СУБД не поддерживает ограничения целостности, за исключением
ссылочной, да и то в ограниченном объеме, поддержка целостности данных
фактически является ответственностью приложения
• Неустановленные значения поддерживаются только для объектных ссылок,
для других типов – это забота приложения
• Механизмы триггеров, хранимых процедур и т.п., не поддерживаются
• Ограничение доступа к данным со стороны различных пользователей не
поддерживается или ограниченно поддерживается в Versant
• Ни ODL, ни OQL не поддерживаются (каждая ООСУБД предлагает собственные
языковые средства), запросы, результатами которых являются литеральные
значения или их множества не поддерживаются
• db4o поддерживает только Java или C#, причем для этих языков выпускаются
два разных продукта, остальные хотя и декларируют независимость от языков,
эта независимость является условной (необходимо соблюсти ряд требований,
например, по использованию определенных типов данных)
• Перевод существующего приложения достаточно трудоемок (например,
необходимо перейти на типы данных, поддерживаемые той или иной ООСУБД)
            Современное состояние
С конца 90-х годов в области ООСУБД наблюдался явный упадок. Основные
причины:
• Недостатки ООСУБД, главным из которых является зависимость от языков
программирования
• Отсутствие крупных игроков на рынке (таких как Oracle и IBM)
• Появление объектно-реляционных возможностей в большинстве популярных
SQL-ориентированных СУБД
• Маркетинговая политика крупных компаний, которые сумели внушить
пользователям должное доверие к универсальности, надежности и
масштабируемости своих SQL-ориентированных решений

С середины 2000-х до начала 2010-х некоторое повышение интереса к ООСУБД:
2005 г. – возникновение консорциума ODBMS.ORG
2006 г. – сформирована группа (в рамках OMG) по подготовке новой версии
стандарта объектно-ориентированной модели данных
2008 г. – первая после длительного перерыва конференция, посвященная
проблемам ООСУБД
      Объектные расширения SQL
К объектным расширениям языка SQL (SQL:1999, SQL:2003)
относятся:
• Структурные типы данных, определяемые пользователем;
• Типизированные таблицы;
• Типизированные представления;
• Ссылочные типы.

Кроме того, в стандартах SQL:1999, SQL:2003 появились типы
данных, не относящиеся к объектным расширениям, но
позволяющие хранить в таблицах неатомарные значения, что
также относится к решению проблемы «Impedance Mismatch».
   Типы данных, позволяющие хранить
         неатомарные значения
Типы данных, не относящиеся к ОО расширениям, но позволяющие хранить
неатомарные значения:
    • Массивы (1999): datatype ARRAY [max_cardinality] (может содержать не
    более max_cardinality элементов, индексация от 1)
    • Мультимножества (2003): datatype MULTISET
    • Анонимные строчные типы (1999): ROW( field1, …, fieldN ), где field ::=
    name datatype options
    • Многомерные массивы (2019): datatype MDARRAY [dimension_list], где
    dimension ::= optional_axis_name(min_limit : max_limit)

D. Misev, P. Baumann “SQL Support for Multidimensional Arrays”, Technical Report,
Jacobs University Bremen, 2017

datatype – тип элемента, любой допустимый в SQL тип данных, кроме самого
конструируемого типа коллекции.
          Типы данных, определяемые
                пользователем
• Индивидуальные типы: CREATE TYPE UDT_name AS base_type_name FINAL
  [method_specification_list];
• Структурные типы: CREATE TYPE UDT_name [UNDER UDT_name] AS
  (attribute_definition_list) [ INSTANTIABLE | NOT INSTANTIABLE ] { FINAL | NOT
  FINAL } [reference_type_specification] [method_specification_list]
  attribute_definition ::= attribute_name data_type [ reference_scope] [
  default_value ]

Индивидуальный тип – именованный тип данных, основанный на единственном
предопределенном типе. Индивидуальный тип не наследует от своего опорного типа
набор операций над значениями (требуется явное приведение индивидуального типа
к его базовому типу либо в самом типе нужно явно определить операцию).

Структурный тип данных – именованный типы данных, включающий один или более
атрибутов любого из допустимых в SQL типа данных (включая другие структурные
типы, коллекции, анонимные строчные типы). Дополнительные механизмы:
наследование от ранее определенного структурного типа (только одиночное),
определяемые пользователями методы (поведение структурного типа), ссылки.
             Типизированные таблицы
CREATE TABLE typed_table_name OF UDT_name [UNDER typed_table_name]
[(typed_table_element_list)]
typed_table_element ::= constraint_definition | self-ref_column_definition |
column_options
CREATE VIEW typed_view_name OF UDT_name UNDER base_table_name AS
query_expression
При определении типизированной таблицы указывается ранее определенный
структурный тип, и если в нем содержится n атрибутов, то в таблице
образуется n+1 столбец, дополнительный (первый) столбец называется
самоссылающимся и содержит типизированные уникальные идентификаторы
строк, которые могут генерироваться системой при вставке строк в
типизированную таблицу, явно указываться пользователями или состоять из
комбинации значений других столбцов. Можно определить подтаблицу
типизированной таблицы, если структурный тип подтаблицы является
непосредственным подтипом структурного типа супертаблицы.
В случае типизированных представлений выражение запроса должно
основываться на единственной типизированной таблице (базовой или
представляемой), при этом базисная таблица и определяемое представление
должны быть ассоциированы с одним и тем же структурным типом.
          Ссылочные типы и значения
Спецификация ссылки в UDT              Определение «самоссылающегося» столбца
REF IS SYSTEM GENERATED                REF IS column_name SYSTEM GENERATED
REF USING predefined_type              REF IS column_name USER GENERATED
REF USING (attribute_list)             REF IS DERIVED
Типом «самоссылающегося» столбца является ссылочный тип, ассоциированный со структурным
типом типизированной таблицы. Способ генерации значений ссылочного типа указывается при
определении соответствующего структурного типа (супертипа) и подтверждается при определении
типизированной таблицы (супертаблицы).

Определение ссылочного типа на структурный тип (при типизации столбцов традиционных таблиц,
полей строчных типов и атрибутов структурных типов):
REF( UDT_name ) [ SCOPE typed_table_name REFERENCES ARE [NOT] CHECKED [ON DELETE action] ]
Если раздел SCOPE отсутствовал в определении атрибута структурного типа, то его можно добавить
в конструкции column_options для соответствующего столбца типизированной таблицы.

С типизированной таблицей можно обращаться, как с традиционной таблицей, считая, что у нее
имеются неявно определенные столбцы (атрибуты структурного типа), а можно относиться к
строкам типизированной таблицы, как к объектам соответствующего структурного типа, OID
которых содержатся в «самоссылающемся» столбце.
               Пример использования
               типизированных таблиц
CREATE TYPE EMP_T AS (                  CREATE TYPE PROG_T UNDER EMP_T AS (
     EMP_NAME VARCHAR( 200 ),                PROG_LANG_SKILL VARCHAR( 100 )
     EMP_BDATE DATE,                    ) INSTANTIABLE NOT FINAL;
     EMP_SALARY SALARY,
     DEPT REF( DEPT_T ),                CREATE TABLE PROGRAMMER OF PROG_T
     PROJ REF( PROJ_T )                 UNDER EMPLOYEE;
) INSTANTIABLE NOT FINAL
REF IS SYSTEM GENERATED;

CREATE TABLE EMPLOYEE OF EMP_T(
    REF IS EMP_ID SYSTEM GENERATED,
    DEPT WITH OPTIONS SCOPE DEPARTMENT REFERENCES ARE CHECKED
         ON DELETE SET NULL,
    PROJ WITH OPTIONS SCOPE PROJECT REFERENCES ARE CHECKED ON DELETE SET NULL
);
SELECT EMP_NAME, DEPT -> DEPT_NAME FROM EMPLOYEE WHERE EMP_SALARY <
20000.00;
SELECT EMP_NAME, DEPT -> DEPT_NAME FROM ONLY( EMPLOYEE ) WHERE EMP_SALARY <
20000.00;
     Известные объектно-реляционные
                  СУБД
Реализации: Oracle, IBM DB2, Informix, PostgreSQL (частично).

Очень многие разработчики приложений вместо объектных расширений SQL
используют промежуточное программное обеспечение (middleware) объектно-
реляционного отображения, которое само взаимодействует с базами данных на основе
БАЗОВОГО подмножества языка SQL (т.е. традиционных таблиц).

Такая архитектура эмулирует специализированную ООСУБД, язык запросов которой
максимально приближен к средствам доступа к данным базового языка
программирования, а соответствующая SQL-ориентированная база данных используется
как среда хранения. Промежуточное ПО при этом реализует функциональность
объектного кэша.

  Приложение                       Middleware
                                                        SQL data & queries    SQL
   (объектная      OO data      (преобразования
                                                                             СУБД
     модель)       &queries         моделей)
           Основные подходы к объектно-
            реляционному отображению
1. Использование OO API (JDBC, ADO.NET), которые обеспечивают доступ к
   реляционным данным и их извлечение в форме, более привлекательной для
   разработчиков объектно-ориентированных приложений. API обеспечивает доступ к
   реляционным данным и их извлечение в форме, более привлекательной для
   объектных разработчиков (в виде объектов).
2. Реляционные данные принимаются в качестве модели, с которой следует работать,
   и объекты подстраиваются под этот подход. В этом случае проблема потери
   соответствия решается средствами базового объектно-ориентированного языка
   (используются известные методики преобразования, см. преобразование ER-
   модели в реляционную). Еще одна методика – BLOB-стратегия (упаковка части
   атрибутов в BLOB, за кодирование и декодирование которого отвечает middleware).
   Семенов, Морозов, Порох «Стратегии объектно-реляционного отображения: систематизация и анализ на
   основе паттернов». Труды ИСП РАН, том 8 № 2, 2004.
3. В БД сохраняются не только состояния объектов, но и метаданные, описывающие
   их структуру (определения классов), которые прозрачным образом могут
   использоваться в приложении. Middleware обеспечивает сборку объектных данных
   и их запись по нескольким таблицам с использованием метаданных.
   Klein, Stonis, Jankauskas “EXPRESS/SQL white paper”, 2001.
        Истинная реляционная модель
                   данных
Ключевая идея третьего манифеста – чтобы достичь требуемой объектной
функциональности, не надо абсолютно ничего делать с реляционной моделью;
на основе идей Э. Кодда можно реализовать СУБД, обеспечивающие
возможности по части представления и хранения данных произвольно сложной
структуры, не меньшие тех, которые обеспечивают объектные и SQL-
ориентированные СУБД.
Основное препятствие – тезис Кодда о нормализации отношений (1НФ): в
реляционной базе данных должны содержаться только отношения, атрибуты
которых определены на «доменах, элементы которых являются атомарными
(не составными) значениями».

К. Дейт: «Я согласен с Коддом, что желательно оставаться в рамках логики
первого порядка, если это возможно. В то же время я отвергаю идею
"атомарных значений", по крайней мере, в смысле абсолютной атомарности. В
Третьем манифесте мы допускаем наличие доменов, содержащих значения
произвольной сложности. Они могут быть даже отношениями. Тем не менее,
мы остаемся в рамках логики первого порядка.»
      Типы данных истинной реляционной
                   модели
Три категории типов данных: скалярные типы, кортежные типы и типы
отношений.
Скалярный тип – инкапсулированный тип, реальная внутренняя структура
которого скрыта от пользователей. Предлагаются механизмы определения
новых скалярных типов и операций над ними. Типом атрибута определяемого
скалярного типа может являться любой определенный к этому моменту
скалярный тип, кортежный тип или тип отношения.
Некоторые базовые скалярные типы данных должны быть предопределены в
системе. В число этих типов должен входить тип truth value (булевский тип) с
двумя значениями true и false.
Кортежный тип – тип данных, определяемый с помощью генератора типа TUPLE
c указанием множества пар <имя_атрибута, тип_атрибута> (заголовка кортежа).
Типом атрибута кортежного типа может являться любой определенный к этому
моменту скалярный тип, любой кортежный тип и тип отношения. Значением
кортежного типа является кортеж, представляющий собой множество
триплетов <имя_атрибута, тип_атрибута, значение_атрибута>, которое
соответствует заголовку кортежа этого типа.
      Типы данных истинной реляционной
                   модели
Тип отношения – тип данных, определяемый с помощью генератора типа
RELATION c указанием некоторого заголовка кортежа. Значением типа
отношения является заголовок отношения, совпадающий с заголовком кортежа
этого типа отношения, и тело отношения, представляющее собой множество
кортежей, соответствующих этому заголовку.
Кортежные типы и типы отношений не являются инкапсулированными: имеется
возможность прямого доступа к атрибутам. Для всех разновидностей типов
данных поддерживается модель множественного наследования, позволяющая
определять новые типы данных на основе уже определенных типов.
База данных – набор долговременно хранимых именованных переменных
отношений, каждая из которых определена на некотором типе отношения.

При таких определениях значениями атрибутов отношения могут быть не
только значения скалярных типов, но и кортежи, и другие отношения.
Третий манифест: «Каждый кортеж в отношении R содержит в точности одно
значение v для каждого атрибута A в заголовке отношения H. Иными словами, R
находится в первой нормальной форме, 1NF».
         Манипулирование данными в
        истинной реляционной модели
Эталонные средства манипулирования данными: реляционная алгебра Кодда,
реляционная алгебра А.

Языковые средства – язык запросов D:
• для выражения запросов используется алгебраический подход;
• запросы, адресуемые к сложным данным, формулируются более точно, чем
на SQL;
• это же касается сложных операций обновления;
• язык обладает вычислительной полнотой;
• язык претендует на то, чтобы стать открытым стандартом и заменить SQL.
     Поддержка целостности данных в
      истинной реляционной модели
В число обязательных требований истинной реляционной модели входит
требование определения хотя бы одного возможного ключа для каждой
переменной отношения.

Кроме того, говорится, что «любое условное выражение, которое является (или
логически эквивалентно) замкнутой правильно построенной формулой (WFF)
реляционного исчисления, должно быть допустимо в качестве спецификации
ограничения целостности».

Средства поддержки декларативной ссылочной целостности фигурируют только
в разделе рекомендуемых возможностей: «В D следует включить некоторую
декларативную сокращенную форму для выражения ссылочных ограничений
(называемых также ограничениями внешнего ключа)».
Реализации истинной реляционной
            модели
Единственное коммерческое решение:
Dataphor a.k.a D4 (разработка: 1999-2001, c 2001 по 2008:
коммерческий продукт компании Alphora, после ее приобретения
Database Consulting Group продукт выпускается под открытой
лицензией, текущий релиз в 2018 году, исходный код на С#)

Открытые проекты (университеты и индивидуальные разработчики):
• Alf (Ruby)
• Dee (Python)
• DuroDBMS (multiple languages)
• Rel (Java)
• TclRAL (TCL)

Сайт К. Дейта: http://www.thethirdmanifesto.com (похоже, закрыт)
Сайт Х. Дарвена: https://www.dcs.warwick.ac.uk/~hugh/TTM/
